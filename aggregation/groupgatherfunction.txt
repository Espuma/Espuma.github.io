//http://bl.ocks.org/mbostock/1093130  click functionality I want, simple on/off toggle
//http://jsfiddle.net/mdml/Q7uNz data structure I want, simple graph json

//for gravity purposes, only nodes with an overwhelming amount of a single read get a groep assigned. 
//1.5/totalGroups, if there is only one origin that has such a high value.
//If there are more with that value, recalculate again with that number for totalGroups
//if no consensus is reached anywhere, assign groep 0
//lets skip the fiddling on this exact number.

//origin=for gravity
//group=ID for aggregation
//reads and their ratios are used to determine both group and origin

//I might want an option (in UI) at n=5 to remove any node that has no children (remove all single-node-subgraphs)

neighbours={}
function determineneighbours(links){//can probably be built in collection of edges
	for(edge in graaf.edges){
		link=graaf.edges[edge]
		neighbours[link.source.id]!=undefined?neighbours[link.source.id].push(parseInt(link.target.id)):neighbours[link.source.id]=[parseInt(link.target.id)]
		neighbours[link.target.id]!=undefined?neighbours[link.target.id].push(parseInt(link.source.id)):neighbours[link.target.id]=[parseInt(link.source.id)]
		//now neighbours[x] will contain all link partners of x
	}
}

function matchcriteria(node,partner,n){
	//case n=1 not necessary, because this is already assigned in the beginning.
	if(n==2 && neighbours[node.id].length==2 && neighbours[partner.id].length==2){return true}
	if(n=3 && node.assignedgroup==partner.assignedgroup){return true}
	if(n=4){
		for(origin in node.proportions){
			if(node.proportions[origin].waarde>=0.8*partner.proportions[origin].waarde && node.proportions[origin].waarde<=1.2*partner.proportions[origin].waarde){return true}else{break}
		//only considers waarde, not waarde/total
	}
	if(n=5){return true)
		//all partners are eligible for this group, making a group for every set of connected nodes


//nodeneighbours needs to be full for the determination of the different groups
//group and proportions already need to be determined as well
//that means this needs to be filled in each node, after nodes and edges are gathered from file in XXXparse


var level1,level2,level3,level4,level5;
	
function determineZoomLevelGroups(){
	for(n=0;n<=4;n++){
		var currentlevel={"nodes":[],"neighbours":[],"edges":[]},
			groupid=0;
		for(gn in graaf.nodes){
			var node=graaf.nodes[gn]
			if(n=0){
				var groupid+=1,
					node.groupid[n]=groupid;
			}else {
			//TODO:recursive search element for n=1 to consolidate whole string of nodes
			
				if(node.id[n]==0){//select unassigned node, put in new group, collect whole group
					var cgn=[],//nodes in current group (children)
						oe=[],//(Outside Edges) nodes not in group that are connected to those that are
						groupsize=0,
						prevgroupsize=0
						groepid+=1,
						node.groupid[n]=groepid;
					cgn.push(node.groupid[n-1])//will contain whole group with same groepid
					prevgroupsize=[groupsize,groupsize=cgn.length][0]
					do{
						for(nd in cgn){
							for(num in neighbours[nd]){//TODO:check for nodes with no edges
								partner=graaf.nodes[neighbours[nd][num]-1]
								if matchcriteria(graaf.nodes[parseInt(nd)-1],partner,n){
									graaf.nodes[neighbours[nd][num]-1].groupid[n]=groepid
									if(!(partner.groupid[n-1] in cgn)){cgn.push(partner.groupid[n-1])}
									prevgroupsize=[groupsize,groupsize=cgn.length][0]
								}else{
									if(!(partner.groupid[n-1] in oe)){oe.push(partner.groupid[n-1])}
								}
							}
							if(nd=cgn.length){prevgroupsize=cgn.length}//not in correct place yet?
						}
					}while{prevgroupsize!=groupsize}
					currentlevel.nodes.push({"id":groepid,"children":cgn})
					currentlevel.neighbours.push({"id":groepid,"edgesto":oe})
				}
			}
		}
		//perhaps need new way to draw edges, so that source and target are evaluated on the same level. 
		//Here, we evaluate for the highest n, but that might nog be necessary
		for(oe in currentlevel.neighbours){
			for(buur in oe.edgesto){
				currentlevel.edges.push({"source":oe.id,"target":lookupGroup(n,currentlevel.nodes,buur)}
			}
		}
		
		if(n=0){var level1=currentlevel}			
		if(n=1){var level2=currentlevel}			
		if(n=2){var level3=currentlevel}		
		if(n=3){var level4=currentlevel}		
		if(n=4){var level5=currentlevel}
	}
}

lookupGroup(n,graafnodes,oeid){
	for(nd in graafnodes){
		node=graafnodes[nd]
		if(node.id[n-1]===oeid){
			return node.id[n]
		}
	}
}
	