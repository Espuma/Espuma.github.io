//use for, not forEach. for is way faster
//http://bl.ocks.org/mbostock/1093130  click functionality I want, simple on/off toggle
//http://jsfiddle.net/mdml/Q7uNz data structure I want, simple graph json

//for gravity purposes, only nodes with an overwhelming amount of a single read get a groep assigned. 
//1.5/totalGroups, if there is only one origin that has such a high value.
//If there are more with that value, recalculate again with that number for totalGroups
//if no consensus is reached anywhere, assign groep 0
//lets skip the fiddling on this exact number.

//origin=for gravity
//group=ID for aggregation
//reads and their ratios are used to determine both group and origin

//I might want an option (in UI) at n=5 to remove any node that has no children (remove all single-node-subgraphs)

neighbours={}
function determineneighbours(links){//can probably be built in collection of edges
	for(edge in graaf.edges){
		link=graaf.edges[edge]
		neighbours[link.source.id]!=undefined?neighbours[link.source.id].push(parseInt(link.target.id)):neighbours[link.source.id]=[parseInt(link.target.id)]
		neighbours[link.target.id]!=undefined?neighbours[link.target.id].push(parseInt(link.source.id)):neighbours[link.target.id]=[parseInt(link.source.id)]
		//now neighbours[x] will contain all link partners of x
	}
}

function matchcriteria(node,partner,n){
	//case n=1 not necessary, because this is already assigned in the beginning.
	if(n==2){
		if(neighbours[node.id].length==2){
			if(neighbours[partner.id].length==2){
				return true
			}else{
				return false
			}
		}else{
			return false
		}
	}
	if(n=3){node.assignedgroup==partner.assignedgroup?return true:return false}
	if(n=4){
		for each origin, compare readratios between node and partner//needs some work!
			if they all match within some error rate (20%?)
				return true
	}
	if(n=5){return true)
		//all partners are eligible for this group, making a group for every set of connected nodes


//nodeneighbours needs to be full for the determination of the different groups
//group and proportions already need to be determined as well
//that means this needs to be filled in each node, after nodes and edges are gathered from file in XXXparse
var level1={"nodes":[],"edges":[]},
	level2={"nodes":[],"edges":[]},
	level3={"nodes":[],"edges":[]},
	level4={"nodes":[],"edges":[]},
	level5={"nodes":[],"edges":[]};
	
function determineZoomLevelGroups(){
	for(n=0;n<=4;n++){
		currentlevel={"nodes":[],"edges":[]}
		groupid=0
		for(gn in graaf.nodes){
			var node=graaf.nodes[gn],
			if(n=0){
				var groupid+=1,
					node.groupid[n]=groupid
			}else {
				if(node.id[n]==0){//select unassigned node, put in new group, collect whole group
					var cgn=[],//nodes in current group (children)
						oe=[],//(Outside Edges) nodes not in group that are connected to those that are
						groupsize=0,
						prevgroupsize=0
						groepid+=1,
						node.groupid[n]=groepid
					cgn.push(node.groupid[0])//all children of node[groepid] will get added to this list.
					prevgroupsize=[groupsize,groupsize=cgn.length][0]
					do{
						for(nd in cgn){
							//TODO:if-not-in-list check, otherwise it will get added every time. for example:
							//if all partners are already in oe or cgn
							for(num in neighbours[nd]){//TODO:check for nodes with no edges
								partner=graaf.nodes[neighbours[nd][num]-1]
								if matchcriteria(graaf.nodes[parseInt(nd)-1],partner,n){
									graaf.nodes[neighbours[nd][num]-1].groupid[n]=groepid
									cgn.push(partner.groupid[0])
									prevgroupsize=[groupsize,groupsize=cgn.length][0]
								}else{
									oe.push(partner.groupid[0])//TODO:if-not-in-list check as well
								}
							}
							if(nd=cgn.length){prevgroupsize=cgn.length}//not in correct place yet?
						}
					}while{prevgroupsize!=groupsize}
					
					//TODO:add cgn and oe to currentlevel
				}
			}
		}
		//TODO:simplify oe, or rebuild edges from oe.
		if(n=0){var level1=currentlevel}			
		if(n=1){var level2=currentlevel}			
		if(n=2){var level3=currentlevel}		
		if(n=3){var level4=currentlevel}		
		if(n=4){var level5=currentlevel}
	}
}			
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				