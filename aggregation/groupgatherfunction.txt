//use for, not forEach. for is way faster
//http://bl.ocks.org/mbostock/1093130  click functionality I want, simple on/off toggle
//http://jsfiddle.net/mdml/Q7uNz data structure I want, simple graph json

//for gravity purposes, only nodes with an overwhelming amount of a single read get a groep assigned. 
//1.5/totalGroups, if there is only one origin that has such a high value.
//If there are more with that value, recalculate again with that number for totalGroups
//if no consensus is reached anywhere, assign groep 0
//lets skip the fiddling on this exact number.

//origin=for gravity
//group=ID for aggregation
//reads and their ratios are used to determine both group and origin
//meaning of origin and group is still twisted in stringit.js

//I might want an option (in UI) at n=5 to remove any node that has no children (remove all single-node-subgraphs)

neighbours={}
function determineneighbours(nodes){//can probably be built in collection of edges
	for(link in links){
		neighbours[link.source.id]!=undefined?neighbours[link.source.id].push(link.target.id):neighbours[link.source.id]=[link.target.id]
		neighbours[link.target.id]!=undefined?neighbours[link.target.id].push(link.source.id):neighbours[link.target.id]=[link.source.id]
		//now neighbours[x] will contain all link partners of x
	}
}

function matchcriteria(node,partner,n){
	//case n=1 not necessary, because this is already assigned in the beginning.
	if(n==2){
		if(neighbours[node.id].length==2){
			if(neighbours[partner.id].length==2){
				return true
			}else{
				return false
			}
		}else{
			return false
		}
	}
	if(n=3){node.assignedgroup==partner.assignedgroup?return true:return false}
	if(n=4){
		for each origin, compare readratios between node and partner//needs some work!
			if they all match within some error rate (20%?)
				return true
	}
	if(n=5){return true)
		//all partners are eligible for this group, making a group for every set of connected nodes


//nodeneighbours needs to be full, and group and proportions need to be determined.
//that means this needs to be filled in each node, after nodes and edges are gathered from file in XXXparse

function determineZoomLevelGroups(){
zoomlevel=[1,2,3,4,5]
group=0//current group id number
cgl=[]//all nodes in current group

	for node in graaf.nodes:
		for n in zoomlevel:
			if n=1:
				group+=1
				node.id=group
			else
				if node.id[n]==0:
					group+=1
					node.id[n]=group
					cgl+=node.name
					for sub in group:
						for partner in neighbours[sub]:
							if not in group yet:
								if matchcriteria(node,partner,n):
									partner.id[n]=group
									cgl+=partner.name
							if all partners are in group:
								//collect all outside links and do something with them later.
								//will need to save a set of links for every zoomlevel...
								//needs some work!
								break
				